<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæ·±åº¦æŸ¥çœ‹å™¨</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            color: white;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
        }
        h2 {
            margin-top: 0; 
        }
        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* ä¾§æ æ ·å¼ */
        .sidebar {
            position: fixed;
            top: 0;
            height: 100vh;
            width: 350px;
            background: rgba(51, 51, 51, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .sidebar.right {
            right: 0;
            transform: translateX(100%);
        }
        
        .sidebar.open {
            transform: translateX(0);
        }
        
        .sidebar-toggle {
            position: fixed;
            top: 20px;
            width: 50px;
            height: 50px;
            background: rgba(76, 175, 80, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }
        
        .sidebar-toggle:hover {
            background: rgba(76, 175, 80, 1);
            transform: scale(1.1);
        }
        
        .sidebar-toggle::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #4CAF50;
            border-radius: 50%;
            top: 8px;
            right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .toggle-left {
            left: 20px;
        }
        
        .toggle-right {
            right: 20px;
        }
        
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #555;
            padding-bottom: 15px;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-btn:hover {
            color: #fff;
        }
        
        /* ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– */
        @media (max-width: 768px) {
            .sidebar {
                width: 90vw;
                max-width: 350px;
            }
            
            .sidebar-toggle {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            .main-title {
                font-size: 18px;
                padding: 8px 16px;
                top: 15px;
            }
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: rgba(68, 68, 68, 0.3);
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.6);
            border-radius: 3px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .canvas-container {
            text-align: center;
            margin: 0;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        canvas {
            border: 2px solid #444;
            max-width: calc(100vw - 40px);
            max-height: calc(100vh - 40px);
            cursor: grab;
        }
        
        .main-title {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;
            background: rgba(34, 34, 34, 0.9);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            margin: 0;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        .control-group {
            background: rgba(68, 68, 68, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #555;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 16px;
        }
        
        .control-item {
            margin: 15px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }
        
        input[type="color"] {
            vertical-align: middle;
            margin-left: 10px;
        }
        
        input[type="file"] {
            width: 100%;
            margin: 8px 0;
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px;
            border-radius: 4px;
        }
        
        .value-display {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .load-images {
            background: rgba(68, 68, 68, 0.3);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #555;
        }
        
        .image-inputs {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .image-input-group {
            display: flex;
            flex-direction: column;
        }
        
        .preview-item {
            text-align: center;
            margin-top: 10px;
        }
        
        .preview-item img {
            max-width: 280px;
            max-height: 150px;
            border: 1px solid #666;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <!-- æ‚¬æµ®ä¾§æ åˆ‡æ¢æŒ‰é’® -->
    <button class="sidebar-toggle toggle-left" id="toggleLeftSidebar">ğŸ“</button>
    <button class="sidebar-toggle toggle-right" id="toggleRightSidebar">âš™ï¸</button>
    
    <!-- ä¸»æ ‡é¢˜ -->
    <h1 class="main-title">å…¨æ¯3Då›¾åƒæŸ¥çœ‹å™¨</h1>
    
    <!-- å·¦ä¾§æ ï¼šå›¾åƒåŠ è½½ -->
    <div class="sidebar" id="leftSidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">å›¾åƒåŠ è½½</div>
            <button class="close-btn" id="closeLeftSidebar">Ã—</button>
        </div>
        <div class="load-images">
            <div class="image-inputs">
                <div class="image-input-group">
                    <label for="imageFile">åŸå§‹å›¾åƒ:</label>
                    <input type="file" id="imageFile" accept="image/*">
                    <div class="preview-item">
                        <img id="imagePreview" style="display: none;">
                    </div>
                </div>
                <div class="image-input-group">
                    <label for="depthFile">æ·±åº¦å›¾:</label>
                    <input type="file" id="depthFile" accept="image/*">
                    <div class="preview-item">
                        <img id="depthPreview" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- å³ä¾§æ ï¼šå‚æ•°æ§åˆ¶ -->
    <div class="sidebar right" id="rightSidebar">
        <div class="sidebar-header">
            <div class="sidebar-title">å‚æ•°è®¾ç½®</div>
            <button class="close-btn" id="closeRightSidebar">Ã—</button>
        </div>
        <div class="controls">
            <!-- 3Dæ•ˆæœå‚æ•° -->
            <div class="control-group">
                <h3>3Dæ•ˆæœå‚æ•°</h3>
                <div class="control-item">
                    <label for="threshold">3Dé˜ˆå€¼: <span id="thresholdValue" class="value-display">25</span></label>
                    <input type="range" id="threshold" min="5" max="60" value="25" step="1">
                </div>
                <div class="control-item">
                    <label for="protrude">çªå‡ºç¨‹åº¦: <span id="protrudeValue" class="value-display">0</span></label>
                    <input type="range" id="protrude" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
            </div>
            
            <!-- å…¨æ¯æ˜¾ç¤ºå‚æ•° -->
            <div class="control-group">
                <h3>å…¨æ¯æ˜¾ç¤ºå‚æ•°</h3>
                <div class="control-item">
                    <label for="x_diff">xåè½¬: <span id="x_diffValue" class="value-display">0</span></label>
                    <input type="range" id="x_diff" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="y_diff">yåè½¬: <span id="y_diffValue" class="value-display">0</span></label>
                    <input type="range" id="y_diff" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <button id="enableGyroBtn">å¯ç”¨é™€èºä»ªæ§åˆ¶</button>
                    <span id="gyroStatus" style="margin-left:10px;color:#aaa;">æœªå¯ç”¨</span>
                </div>
                <div class="control-item">
                    <label for="gyroSensitivity">é™€èºä»ªçµæ•åº¦: <span id="gyroSensitivityValue" class="value-display">1.00</span></label>
                    <input type="range" id="gyroSensitivity" min="0" max="3" value="1" step="0.01">
                </div>
            </div>
            
            <!-- å›¾åƒå˜æ¢å‚æ•° -->
            <div class="control-group">
                <h3>å›¾åƒå˜æ¢</h3>
                <div class="control-item">
                    <label for="scaleX">Xç¼©æ”¾: <span id="scaleXValue" class="value-display">1.0</span></label>
                    <input type="range" id="scaleX" min="0" max="2" value="1" step="0.01">
                </div>
                <div class="control-item">
                    <label for="scaleY">Yç¼©æ”¾: <span id="scaleYValue" class="value-display">1.0</span></label>
                    <input type="range" id="scaleY" min="0" max="2" value="1" step="0.01">
                </div>
                <div class="control-item">
                    <label for="offsetX">Xåç§»: <span id="offsetXValue" class="value-display">0.0</span></label>
                    <input type="range" id="offsetX" min="-1" max="1" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="offsetY">Yåç§»: <span id="offsetYValue" class="value-display">0.0</span></label>
                    <input type="range" id="offsetY" min="-1" max="1" value="0" step="0.01">
                </div>
            </div>
            
            <!-- æ¨¡ç³Šæ•ˆæœå‚æ•° -->
            <div class="control-group">
                <h3>æ¨¡ç³Šæ•ˆæœ</h3>
                <div class="control-item">
                    <label for="blurSize">æ¨¡ç³Šå¤§å°: <span id="blurSizeValue" class="value-display">10</span></label>
                    <input type="range" id="blurSize" min="0" max="50" value="5" step="1">
                </div>
                <div class="control-item">
                    <label for="blurDepth">æ¨¡ç³Šæ·±åº¦é˜ˆå€¼: <span id="blurDepthValue" class="value-display">0.25</span></label>
                    <input type="range" id="blurDepth" min="0" max="1" value="0.25" step="0.01">
                </div>
                <div class="control-item">
                    <label for="depthImageBlurSize">æ·±åº¦å›¾æ¨¡ç³Š: <span id="depthImageBlurSizeValue" class="value-display">50</span></label>
                    <input type="range" id="depthImageBlurSize" min="0" max="100" value="50" step="1">
                </div>
            </div>

            <!-- è¾¹æ¡†æ•ˆæœå‚æ•° -->
            <div class="control-group">
                <h3>è¾¹æ¡†æ•ˆæœ</h3>
                <div class="control-item">
                    <label for="borderColor">è¾¹æ¡†é¢œè‰²:<input type="color" id="borderColor" value="#000000"></label>
                </div>
                <div class="control-item">
                    <label for="borderSizeX">æ°´å¹³è¾¹æ¡†å¤§å°: <span id="borderSizeXValue" class="value-display">0.0</span></label>
                    <input type="range" id="borderSizeX" min="0" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="borderSizeY">å‚ç›´è¾¹æ¡†å¤§å°: <span id="borderSizeYValue" class="value-display">0.0</span></label>
                    <input type="range" id="borderSizeY" min="0" max="0.5" value="0" step="0.01">
                </div>
            </div>
        </div>
    </div>
    
    <!-- ä¸»å†…å®¹åŒºåŸŸï¼šç”»å¸ƒ -->
    <div class="container">
        <div class="canvas-container">
            <canvas id="glCanvas"></canvas>
        </div>
    </div>
    
    <script>
        // WebGLä¸Šä¸‹æ–‡å’Œç€è‰²å™¨ç¨‹åº
        let gl;
        let program;
        let uniforms = {};
        let textures = {};
        
        // é¡¶ç‚¹ç€è‰²å™¨æºç 
        const vertexShaderSource = `
            attribute vec3 a_Position;
            attribute vec2 a_TexCoord;
            varying vec2 v_TexCoord;
            
            void main() {
                gl_Position = vec4(a_Position, 1.0);
                v_TexCoord = a_TexCoord;
            }
        `;
        
        // ç‰‡æ®µç€è‰²å™¨æºç 
        const fragmentShaderSource = `
            precision mediump float;
            
            #define gaussian_blur mat3(1, 2, 1, 2, 4, 2, 1, 2, 1) * 0.0625
            #define box_blur mat3(1, 1, 1, 1, 1, 1, 1, 1, 1) * 0.1111
            
            uniform sampler2D g_Texture0;
            uniform sampler2D g_Texture1;
            uniform sampler2D g_Texture2;
            uniform vec3 g_Screen;
            
            uniform float u_threshold;
            uniform float u_protrude;
            uniform float u_x_diff;
            uniform float u_y_diff;
            
            uniform float u_scaleX;
            uniform float u_scaleY;
            uniform float u_offsetX;
            uniform float u_offsetY;
            
            uniform float u_blurSize;
            uniform float u_blurDepth;
            uniform float u_depthImageBlurSize;
            
            uniform vec3 u_borderColor;
            uniform float u_borderSizeX, u_borderSizeY;
            
            varying vec2 v_TexCoord;
            
            vec2 mirrored(vec2 v) {
                vec2 m = mod(v, 2.);
                return mix(m, 2.0 - m, step(1.0, m));
            }
            
            vec4 convolute(vec2 uv, mat3 kernel, float size) {
                if(size < 1.0) return texture2D(g_Texture1, uv);
                vec4 color = vec4(0., 0., 0., 0.);
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        vec2 offset = vec2(float(x - 1), float(y - 1)) / g_Screen.xy * size;
                        color += texture2D(g_Texture1, uv + offset) * kernel[x][y];
                    }
                }
                return color;
            }
            
            vec4 convoluteDepth(vec2 uv, mat3 kernel, float size) {
                if(size < 1.0) return texture2D(g_Texture2, uv);
                vec4 color = vec4(0., 0., 0., 0.);
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        vec2 offset = vec2(float(x - 1), float(y - 1)) / g_Screen.xy * size;
                        color += texture2D(g_Texture2, uv + offset) * kernel[x][y];
                    }
                }
                return color;
            }
            
            vec4 depthQuilts(vec2 iuv) {
                vec2 fractCoord = fract(iuv);
                float valueId = u_x_diff;
                float valueIdY = u_y_diff;
                
                vec2 uv = vec2(u_scaleX, u_scaleY) * (fractCoord - 0.5) + 0.5 + vec2(u_offsetX, u_offsetY);
                
                vec4 depthMap = convoluteDepth(uv, box_blur, u_depthImageBlurSize);//[0,1]
                float xOffset = (depthMap.r - 0.5 + u_protrude) * ((valueId) * 2.0 / u_threshold);
                float yOffset = (depthMap.r - 0.5 + u_protrude) * ((valueIdY) * 2.0 / u_threshold);
                vec2 fake3d = vec2(uv.x + xOffset, uv.y + yOffset);

                if((depthMap.r - 0.5 + u_protrude < 0.) && 
                    (fractCoord.x < u_borderSizeX || fractCoord.y < u_borderSizeY || 
                    fractCoord.x > (1. - u_borderSizeX) || fractCoord.y > (1. - u_borderSizeY))) {
                    return vec4(u_borderColor, 1.0);
                }

                vec4 color = depthMap.r < u_blurDepth ? 
                    convolute(mirrored(fake3d), gaussian_blur, u_blurSize) : 
                    texture2D(g_Texture1, fake3d);
                
                return color;
            }
            
            void main() {
                vec2 uv = v_TexCoord.xy;
                gl_FragColor = depthQuilts(uv);
            }
        `;
        
        // åˆå§‹åŒ–WebGL
        function initWebGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || canvas.getContext('experimental-webgl', { preserveDrawingBuffer: true });
            
            if (!gl) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL');
                return false;
            }
            
            return true;
        }
        
        // åˆ›å»ºç€è‰²å™¨
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('ç€è‰²å™¨ç¼–è¯‘é”™è¯¯:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // åˆ›å»ºç€è‰²å™¨ç¨‹åº
        function createProgram() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('ç€è‰²å™¨ç¨‹åºé“¾æ¥é”™è¯¯:', gl.getProgramInfoLog(program));
                return false;
            }
            
            gl.useProgram(program);
            return true;
        }
        
        // è·å–uniformä½ç½®
        function getUniforms() {
            const uniformNames = [
                'g_Texture0', 'g_Texture1', 'g_Texture2', 'g_Screen',
                'u_threshold', 'u_protrude', 'u_x_diff', 'u_y_diff',
                'u_scaleX', 'u_scaleY', 'u_offsetX', 'u_offsetY',
                'u_blurSize', 'u_blurDepth', 'u_depthImageBlurSize',
                'u_borderColor', 'u_borderSizeX', 'u_borderSizeY'
            ];
            
            uniformNames.forEach(name => {
                uniforms[name] = gl.getUniformLocation(program, name);
            });
        }
        
        // åˆ›å»ºçº¹ç†
        function createTexture(image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            
            return texture;
        }
        
        // è®¾ç½®å‡ ä½•ä½“
        function setupGeometry() {
            const vertices = new Float32Array([
                -1.0, -1.0, 0.0, 0.0, 1.0,
                 1.0, -1.0, 0.0, 1.0, 1.0,
                -1.0,  1.0, 0.0, 0.0, 0.0,
                 1.0,  1.0, 0.0, 1.0, 0.0
            ]);
            
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_Position');
            const texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 20, 0);
            
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 20, 12);
        }

        // 16è¿›åˆ¶é¢œè‰²è½¬RGB
        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255.0,
                g: parseInt(result[2], 16) / 255.0,
                b: parseInt(result[3], 16) / 255.0
            } : { r: 0, g: 0, b: 0 };
        }
        
        // æ¸²æŸ“åœºæ™¯
        function render() {
            const canvas = gl.canvas;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // è®¾ç½®çº¹ç†
            if (textures.image) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, textures.image);
                gl.uniform1i(uniforms.g_Texture1, 1);
            }
            
            if (textures.depth) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, textures.depth);
                gl.uniform1i(uniforms.g_Texture2, 2);
            }
            
            // è®¾ç½®uniformå€¼
            gl.uniform3f(uniforms.g_Screen, canvas.width, canvas.height, 1.0);
            
            // ä»æ§ä»¶è·å–å‚æ•°å€¼
            gl.uniform1f(uniforms.u_threshold, parseFloat(document.getElementById('threshold').value));
            gl.uniform1f(uniforms.u_protrude, parseFloat(document.getElementById('protrude').value));
            gl.uniform1f(uniforms.u_x_diff, parseFloat(document.getElementById('x_diff').value));
            gl.uniform1f(uniforms.u_y_diff, parseFloat(document.getElementById('y_diff').value));
            
            gl.uniform1f(uniforms.u_scaleX, parseFloat(document.getElementById('scaleX').value));
            gl.uniform1f(uniforms.u_scaleY, parseFloat(document.getElementById('scaleY').value));
            gl.uniform1f(uniforms.u_offsetX, parseFloat(document.getElementById('offsetX').value));
            gl.uniform1f(uniforms.u_offsetY, parseFloat(document.getElementById('offsetY').value));
            
            gl.uniform1f(uniforms.u_blurSize, parseFloat(document.getElementById('blurSize').value));
            gl.uniform1f(uniforms.u_blurDepth, parseFloat(document.getElementById('blurDepth').value));
            gl.uniform1f(uniforms.u_depthImageBlurSize, parseFloat(document.getElementById('depthImageBlurSize').value));
            
            const borderColorHex = document.getElementById('borderColor').value;
            const borderColorRgb = hexToRgb(borderColorHex);
            gl.uniform3f(uniforms.u_borderColor, borderColorRgb.r, borderColorRgb.g, borderColorRgb.b);
            gl.uniform1f(uniforms.u_borderSizeX, parseFloat(document.getElementById('borderSizeX').value));
            gl.uniform1f(uniforms.u_borderSizeY, parseFloat(document.getElementById('borderSizeY').value));
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        // åŠ è½½å›¾åƒæ–‡ä»¶
        function loadImage(file, textureKey, previewId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    textures[textureKey] = createTexture(img);

                    // è®°å½•çº¹ç†å°ºå¯¸
                    const w = img.naturalWidth || img.width || 0;
                    const h = img.naturalHeight || img.height || 0;
                    if (textureKey === 'image') {
                        textures.imageWidth = w;
                        textures.imageHeight = h;
                    } else if (textureKey === 'depth') {
                        textures.depthWidth = w;
                        textures.depthHeight = h;
                    }

                    // è‡ªé€‚åº”è°ƒæ•´ç”»å¸ƒåˆ†è¾¨ç‡ï¼šä¼˜å…ˆä½¿ç”¨åŸå›¾å°ºå¯¸ï¼›å¦‚æœªæä¾›åŸå›¾åˆ™ä½¿ç”¨æ·±åº¦å›¾å°ºå¯¸
                    (function adjustCanvasSize() {
                        const canvas = document.getElementById('glCanvas');
                        if (!canvas) return;
                        let targetW = 0, targetH = 0;
                        if (textures.imageWidth && textures.imageHeight) {
                            targetW = textures.imageWidth;
                            targetH = textures.imageHeight;
                        } else if (textures.depthWidth && textures.depthHeight) {
                            targetW = textures.depthWidth;
                            targetH = textures.depthHeight;
                        }
                        if (targetW > 0 && targetH > 0) {
                            // ä»…å½“å˜åŒ–æ—¶å†è®¾ç½®ï¼Œé¿å…æ— è°“é‡ç»˜
                            if (canvas.width !== targetW || canvas.height !== targetH) {
                                canvas.width = Math.floor(targetW);
                                canvas.height = Math.floor(targetH);
                            }
                        }
                    })();

                    const preview = document.getElementById(previewId);
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // è®¾ç½®æ§ä»¶äº‹ä»¶ç›‘å¬å™¨
        function setupControls() {
            const controls = [
                'threshold', 'protrude', 'x_diff', 'y_diff',
                'scaleX', 'scaleY', 'offsetX', 'offsetY',
                'blurSize', 'blurDepth', 'depthImageBlurSize',
                'borderSizeX', 'borderSizeY'
            ];
            
            controls.forEach(id => {
                const control = document.getElementById(id);
                const valueDisplay = document.getElementById(id + 'Value');
                
                control.addEventListener('input', function() {
                    let decimals = (this.step.toString().split('.')[1] || []).length;
                    valueDisplay.textContent = parseFloat(this.value).toFixed(decimals > 2 ? 5 : 3);
                    render();
                });
            });

            // é¢œè‰²é€‰æ‹©å™¨ç›‘å¬å™¨
            document.getElementById('borderColor').addEventListener('input', render);
            
            // æ–‡ä»¶è¾“å…¥ç›‘å¬å™¨
            document.getElementById('imageFile').addEventListener('change', function(e) {
                if (e.target.files[0]) {
                    loadImage(e.target.files[0], 'image', 'imagePreview');
                }
            });
            
            document.getElementById('depthFile').addEventListener('change', function(e) {
                if (e.target.files[0]) {
                    loadImage(e.target.files[0], 'depth', 'depthPreview');
                }
            });
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        function init() {
            if (!initWebGL()) return;
            
            if (!createProgram()) return;
            
            getUniforms();
            setupGeometry();
            setupControls();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            // åˆ›å»ºé»˜è®¤çº¹ç†
            const defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, defaultTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
            
            textures.image = defaultTexture;
            textures.depth = defaultTexture;
            textures.imageWidth = 1;
            textures.imageHeight = 1;
            
            render();
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
        
        // ä¾§æ æ§åˆ¶
        function setupSidebarControls() {
            const leftSidebar = document.getElementById('leftSidebar');
            const rightSidebar = document.getElementById('rightSidebar');
            const toggleLeftBtn = document.getElementById('toggleLeftSidebar');
            const toggleRightBtn = document.getElementById('toggleRightSidebar');
            const closeLeftBtn = document.getElementById('closeLeftSidebar');
            const closeRightBtn = document.getElementById('closeRightSidebar');
            
            // å·¦ä¾§æ æ§åˆ¶
            toggleLeftBtn.addEventListener('click', () => {
                leftSidebar.classList.toggle('open');
            });
            
            closeLeftBtn.addEventListener('click', () => {
                leftSidebar.classList.remove('open');
            });
            
            // å³ä¾§æ æ§åˆ¶
            toggleRightBtn.addEventListener('click', () => {
                rightSidebar.classList.toggle('open');
            });
            
            closeRightBtn.addEventListener('click', () => {
                rightSidebar.classList.remove('open');
            });
            
            // ç‚¹å‡»ä¾§æ å¤–éƒ¨å…³é—­
            document.addEventListener('click', (e) => {
                if (!leftSidebar.contains(e.target) && !toggleLeftBtn.contains(e.target)) {
                    leftSidebar.classList.remove('open');
                }
                if (!rightSidebar.contains(e.target) && !toggleRightBtn.contains(e.target)) {
                    rightSidebar.classList.remove('open');
                }
            });
            
            // ESCé”®å…³é—­ä¾§æ 
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    leftSidebar.classList.remove('open');
                    rightSidebar.classList.remove('open');
                }
            });
        }
        
        // åœ¨é¡µé¢åŠ è½½æ—¶è®¾ç½®ä¾§æ æ§åˆ¶
        window.addEventListener('load', setupSidebarControls);

        // äº¤äº’ï¼šåœ¨ç”»å¸ƒä¸Šæ‹–æ‹½ä»¥è°ƒæ•´ x_diff / y_diff
    (function enableDragToAdjustDiff() {
            const canvas = document.getElementById('glCanvas');
            const xSlider = document.getElementById('x_diff');
            const ySlider = document.getElementById('y_diff');
            const xLabel = document.getElementById('x_diffValue');
            const yLabel = document.getElementById('y_diffValue');

            if (!canvas || !xSlider || !ySlider || !xLabel || !yLabel) return;

            let dragging = false;
            let startX = 0;
            let startY = 0;
            let startXVal = parseFloat(xSlider.value);
            let startYVal = parseFloat(ySlider.value);

            // å°†åƒç´ æ‹–æ‹½æ˜ å°„åˆ° [-0.5, 0.5] èŒƒå›´çš„å¢é‡ï¼ŒæŒ‰ç”»å¸ƒå°ºå¯¸è‡ªé€‚åº”
            function pxToDelta(dx, dy) {
                const rangeMin = parseFloat(xSlider.min); 
                const rangeMax = parseFloat(xSlider.max);
                const range = rangeMax - rangeMin;
                // æ¨ªå‘ï¼šæ‹–æ»¡ç”»å¸ƒå®½åº¦ç›¸å½“äºæ•´ä¸ªèŒƒå›´
                const deltaX = (-dx / canvas.clientWidth) * range;
                // çºµå‘ï¼šå‘ä¸Šæ‹–ä¸ºæ­£ï¼ˆä¸ UI ä¸€è‡´å¯æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰
                const deltaY = (-dy / canvas.clientHeight) * range;
                return { deltaX, deltaY };
            }

            function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

            function updateUI(xVal, yVal) {
                xSlider.value = xVal.toFixed(3);
                ySlider.value = yVal.toFixed(3);
                xLabel.textContent = parseFloat(xSlider.value).toFixed(3);
                yLabel.textContent = parseFloat(ySlider.value).toFixed(3);
                render();
            }

            canvas.addEventListener('mousedown', (e) => {
                dragging = true;
                canvas.style.cursor = 'grabbing';
                startX = e.clientX;
                startY = e.clientY;
                startXVal = parseFloat(xSlider.value);
                startYVal = parseFloat(ySlider.value);
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const { deltaX, deltaY } = pxToDelta(dx, dy);
                const newX = clamp(startXVal + deltaX, parseFloat(xSlider.min), parseFloat(xSlider.max));
                const newY = clamp(startYVal + deltaY, parseFloat(ySlider.min), parseFloat(ySlider.max));
                updateUI(newX, newY);
            });

            function endDrag() {
                if (!dragging) return;
                dragging = false;
                canvas.style.cursor = 'grab';
            }

            window.addEventListener('mouseup', endDrag);
            window.addEventListener('mouseleave', endDrag);
        })();

        // é™€èºä»ªæ§åˆ¶ x_diff / y_diff
        (function enableGyroControl() {
            const btn = document.getElementById('enableGyroBtn');
            const statusEl = document.getElementById('gyroStatus');
            const sensSlider = document.getElementById('gyroSensitivity');
            const sensLabel = document.getElementById('gyroSensitivityValue');
            const xSlider = document.getElementById('x_diff');
            const ySlider = document.getElementById('y_diff');
            const xLabel = document.getElementById('x_diffValue');
            const yLabel = document.getElementById('y_diffValue');

            if (!btn || !statusEl || !sensSlider || !sensLabel) return;

            let enabled = false;
            let rafId = null;
            // å¹³æ»‘ä¸é™åˆ¶
            let targetX = 0, targetY = 0;
            let currentX = parseFloat(xSlider.value), currentY = parseFloat(ySlider.value);
            const alpha = 0.15; // ä½é€šæ»¤æ³¢ç³»æ•°ï¼Œè¶Šå¤§è¶Šè·Ÿæ‰‹
            // ä»¥å¯ç”¨æ—¶å§¿æ€ä¸ºé›¶åŸºå‡†
            let baseBeta = null, baseGamma = null; // è®°å½•å¯ç”¨åçš„é¦–å¸§å§¿æ€
            let startXAtEnable = parseFloat(xSlider.value), startYAtEnable = parseFloat(ySlider.value); // å¯ç”¨æ—¶æ»‘å—çš„åŸºå‡†å€¼

            function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

            function setDiff(x, y) {
                xSlider.value = x.toFixed(3);
                ySlider.value = y.toFixed(3);
                xLabel.textContent = parseFloat(xSlider.value).toFixed(3);
                yLabel.textContent = parseFloat(ySlider.value).toFixed(3);
                render();
            }

            function updateSensitivityUI() {
                const decimals = (sensSlider.step.toString().split('.')[1] || []).length;
                sensLabel.textContent = parseFloat(sensSlider.value).toFixed(decimals > 2 ? 5 : 3);
            }
            sensSlider.addEventListener('input', updateSensitivityUI);
            updateSensitivityUI();

            // å°†è®¾å¤‡æ–¹å‘(æˆ–ç›¸å¯¹å˜åŒ–)æ˜ å°„åˆ° [-0.5, 0.5]
            // ä½¿ç”¨ gamma(æ°´å¹³å·¦å³) -> x_diff, beta(å‰åä¿¯ä»°) -> y_diff
            // ä¾æ®å±å¹•æ–¹å‘è¿›è¡Œç®€å•é€‚é…
            function orientationToDiff(beta, gamma) {
                const sens = parseFloat(sensSlider.value); // 0~3
                // è®¾å¤‡åŸå§‹èŒƒå›´ï¼šbeta [-180,180]ï¼Œgamma [-90,90]
                // å…ˆå½’ä¸€åŒ–åˆ° [-1,1]ï¼Œå†ä¹˜ä»¥ 0.5 ä¸çµæ•åº¦ï¼Œå¹¶é™åˆ¶
                const normGamma = clamp(gamma / 90, -1, 1); // å·¦å³
                const normBeta = clamp(beta / 90, -1, 1);   // å‰å

                let x = -normGamma * 0.5 * sens;
                let y = -normBeta * 0.5 * sens; // ä¿¯ä»°å‘å‰(æ­£beta)è®© y åè½¬ä¸ºè´Ÿï¼Œä½“éªŒæ›´è‡ªç„¶

                // å±å¹•æ–¹å‘é€‚é…
                const orient = (screen && screen.orientation && screen.orientation.type) || '';
                if (orient.includes('landscape')) {
                    // æ¨ªå±ä¸‹å·¦å³/ä¸Šä¸‹è½´å¯èƒ½å¯¹è°ƒï¼Œè¿›è¡Œè½»åº¦äº¤æ¢ä¸ç¬¦å·è°ƒæ•´
                    const t = x; x = -y; y = t;
                }

                return { x, y };
            }

            function onDeviceOrientation(e) {
                // æŸäº›æµè§ˆå™¨åªæä¾› webkitCompassHeading ç­‰ï¼Œè¿™é‡Œä¸»è¦ç”¨ beta/gamma
                const beta = (typeof e.beta === 'number') ? e.beta : 0;
                const gamma = (typeof e.gamma === 'number') ? e.gamma : 0;
                // é¦–æ¬¡è¯»æ•°ä½œä¸ºé›¶åŸºå‡†ï¼Œé¿å…å¯ç”¨ç¬é—´è·³å˜
                if (baseBeta === null || baseGamma === null) {
                    baseBeta = beta;
                    baseGamma = gamma;
                    // ä¿æŒå½“å‰ç›®æ ‡ä¸ºå¯ç”¨æ—¶æ»‘å—å€¼
                    targetX = startXAtEnable;
                    targetY = startYAtEnable;
                    return;
                }

                // ä½¿ç”¨ç›¸å¯¹å˜åŒ–å€¼é©±åŠ¨ï¼Œå›´ç»•å¯ç”¨æ—¶æ»‘å—å€¼åç§»
                const dBeta = beta - baseBeta;
                const dGamma = gamma - baseGamma;
                const { x, y } = orientationToDiff(dBeta, dGamma); // è¿™é‡Œè¿”å›çš„æ˜¯ç›¸å¯¹åç§»é‡
                const minX = parseFloat(xSlider.min), maxX = parseFloat(xSlider.max);
                const minY = parseFloat(ySlider.min), maxY = parseFloat(ySlider.max);
                targetX = clamp(startXAtEnable + x, minX, maxX);
                targetY = clamp(startYAtEnable + y, minY, maxY);
            }

            function animate() {
                if (!enabled) return;
                // ç®€å•ä½é€šæ»¤æ³¢ï¼Œç¼“åŠ¨åˆ° target
                currentX += (targetX - currentX) * alpha;
                currentY += (targetY - currentY) * alpha;
                setDiff(currentX, currentY);
                rafId = requestAnimationFrame(animate);
            }

            async function requestPermissionIfNeeded() {
                try {
                    const AnyOrientation = window.DeviceOrientationEvent || window.DeviceMotionEvent;
                    if (!AnyOrientation) {
                        throw new Error('ä¸æ”¯æŒè®¾å¤‡æ–¹å‘');
                    }
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS 13+ éœ€è¦æ‰‹åŠ¿è§¦å‘
                        const res = await DeviceOrientationEvent.requestPermission();
                        if (res !== 'granted') throw new Error('æƒé™è¢«æ‹’ç»');
                    }
                    return true;
                } catch (err) {
                    console.warn(err);
                    return false;
                }
            }

            function enable() {
                if (enabled) return;
                enabled = true;
                statusEl.textContent = 'å·²å¯ç”¨';
                statusEl.style.color = '#4CAF50';
                window.addEventListener('deviceorientation', onDeviceOrientation, true);
                // åˆå§‹åŒ–å½“å‰ä¸ç›®æ ‡
                currentX = parseFloat(xSlider.value);
                currentY = parseFloat(ySlider.value);
                startXAtEnable = currentX;
                startYAtEnable = currentY;
                // æ¸…ç©ºåŸºå‡†ï¼Œç­‰å¾…é¦–å¸§å§¿æ€è®¾é›¶
                baseBeta = null;
                baseGamma = null;
                targetX = currentX;
                targetY = currentY;
                animate();
            }

            function disable() {
                if (!enabled) return;
                enabled = false;
                statusEl.textContent = 'æœªå¯ç”¨';
                statusEl.style.color = '#aaa';
                window.removeEventListener('deviceorientation', onDeviceOrientation, true);
                if (rafId) cancelAnimationFrame(rafId);
                rafId = null;
                baseBeta = null;
                baseGamma = null;
            }

            btn.addEventListener('click', async () => {
                if (!enabled) {
                    const ok = await requestPermissionIfNeeded();
                    if (!ok) {
                        statusEl.textContent = 'æƒé™è¢«æ‹’æˆ–ä¸æ”¯æŒ';
                        statusEl.style.color = '#f39c12';
                        return;
                    }
                    enable();
                    btn.textContent = 'å…³é—­é™€èºä»ªæ§åˆ¶';
                } else {
                    disable();
                    btn.textContent = 'å¯ç”¨é™€èºä»ªæ§åˆ¶';
                }
            });
        })();
    </script>
</body>
</html>
