<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全息3D图像查看器深度</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: Arial, sans-serif;
        }
        h2 {
            margin-top: 0; 
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        
        canvas {
            border: 2px solid #444;
            max-width: 100%;
            height: auto;
            cursor: grab;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            background: #333;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        .control-item {
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        input[type="color"] {
            vertical-align: middle;
            margin-left: 10px;
        }
        
        input[type="file"] {
            width: 100%;
            margin: 5px 0;
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px;
        }
        
        .value-display {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .load-images {
            background: #444;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .image-preview {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        
        .preview-item {
            flex: 1;
            text-align: center;
        }
        
        .preview-item img {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>全息3D图像查看器</h1>
        <!-- 图像加载区域 -->
        <button onclick="window.location.href = '/'" >
                返回主页
        </button>
        <br></br>
        <div class="load-images">
            <h2>加载图像</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <label for="imageFile">原始图像:</label>
                    <input type="file" id="imageFile" accept="image/*">
                    <div class="preview-item">
                        <img id="imagePreview" style="display: none;">
                    </div>
                </div>
                <div>
                    <label for="depthFile">深度图:</label>
                    <input type="file" id="depthFile" accept="image/*">
                    <div class="preview-item">
                        <img id="depthPreview" style="display: none;">
                    </div>
                </div>
            </div>
        </div>
        <button id="uploadCanvasBtn">上传渲染内容</button>
        <!-- 渲染画布 -->
        <div class="canvas-container">
            <canvas id="glCanvas"></canvas>
        </div>
        
        <!-- 控制参数 -->
        <div class="controls">
            <!-- 3D效果参数 -->
            <div class="control-group">
                <h3>3D效果参数</h3>
                <div class="control-item">
                    <label for="threshold">3D阈值: <span id="thresholdValue" class="value-display">25</span></label>
                    <input type="range" id="threshold" min="5" max="60" value="25" step="1">
                </div>
                <div class="control-item">
                    <label for="protrude">突出程度: <span id="protrudeValue" class="value-display">0</span></label>
                    <input type="range" id="protrude" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
            </div>
            
            <!-- 全息显示参数 -->
            <div class="control-group">
                <h3>全息显示参数</h3>
                <div class="control-item">
                    <label for="x_diff">x偏转: <span id="x_diffValue" class="value-display">0</span></label>
                    <input type="range" id="x_diff" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="y_diff">y偏转: <span id="y_diffValue" class="value-display">0</span></label>
                    <input type="range" id="y_diff" min="-0.5" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <button id="enableGyroBtn">启用陀螺仪控制</button>
                    <span id="gyroStatus" style="margin-left:10px;color:#aaa;">未启用</span>
                </div>
                <div class="control-item">
                    <label for="gyroSensitivity">陀螺仪灵敏度: <span id="gyroSensitivityValue" class="value-display">1.00</span></label>
                    <input type="range" id="gyroSensitivity" min="0" max="3" value="1" step="0.01">
                </div>
            </div>
            
            <!-- 图像变换参数 -->
            <div class="control-group">
                <h3>图像变换</h3>
                <div class="control-item">
                    <label for="scaleX">X缩放: <span id="scaleXValue" class="value-display">1.0</span></label>
                    <input type="range" id="scaleX" min="0" max="2" value="1" step="0.01">
                </div>
                <div class="control-item">
                    <label for="scaleY">Y缩放: <span id="scaleYValue" class="value-display">1.0</span></label>
                    <input type="range" id="scaleY" min="0" max="2" value="1" step="0.01">
                </div>
                <div class="control-item">
                    <label for="offsetX">X偏移: <span id="offsetXValue" class="value-display">0.0</span></label>
                    <input type="range" id="offsetX" min="-1" max="1" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="offsetY">Y偏移: <span id="offsetYValue" class="value-display">0.0</span></label>
                    <input type="range" id="offsetY" min="-1" max="1" value="0" step="0.01">
                </div>
            </div>
            
            <!-- 模糊效果参数 -->
            <div class="control-group">
                <h3>模糊效果</h3>
                <div class="control-item">
                    <label for="blurSize">模糊大小: <span id="blurSizeValue" class="value-display">10</span></label>
                    <input type="range" id="blurSize" min="0" max="50" value="5" step="1">
                </div>
                <div class="control-item">
                    <label for="blurDepth">模糊深度阈值: <span id="blurDepthValue" class="value-display">0.25</span></label>
                    <input type="range" id="blurDepth" min="0" max="1" value="0.25" step="0.01">
                </div>
                <div class="control-item">
                    <label for="depthImageBlurSize">深度图模糊: <span id="depthImageBlurSizeValue" class="value-display">50</span></label>
                    <input type="range" id="depthImageBlurSize" min="0" max="100" value="50" step="1">
                </div>
            </div>

            <!-- 边框效果参数 -->
            <div class="control-group">
                <h3>边框效果</h3>
                <div class="control-item">
                    <label for="borderColor">边框颜色:<input type="color" id="borderColor" value="#000000"></label>
                </div>
                <div class="control-item">
                    <label for="borderSizeX">水平边框大小: <span id="borderSizeXValue" class="value-display">0.0</span></label>
                    <input type="range" id="borderSizeX" min="0" max="0.5" value="0" step="0.01">
                </div>
                <div class="control-item">
                    <label for="borderSizeY">垂直边框大小: <span id="borderSizeYValue" class="value-display">0.0</span></label>
                    <input type="range" id="borderSizeY" min="0" max="0.5" value="0" step="0.01">
                </div>
            </div>
        </div>
    </div>
    <script>
        // WebGL上下文和着色器程序
        let gl;
        let program;
        let uniforms = {};
        let textures = {};
        
        // 顶点着色器源码
        const vertexShaderSource = `
            attribute vec3 a_Position;
            attribute vec2 a_TexCoord;
            varying vec2 v_TexCoord;
            
            void main() {
                gl_Position = vec4(a_Position, 1.0);
                v_TexCoord = a_TexCoord;
            }
        `;
        
        // 片段着色器源码
        const fragmentShaderSource = `
            precision mediump float;
            
            #define gaussian_blur mat3(1, 2, 1, 2, 4, 2, 1, 2, 1) * 0.0625
            #define box_blur mat3(1, 1, 1, 1, 1, 1, 1, 1, 1) * 0.1111
            
            uniform sampler2D g_Texture0;
            uniform sampler2D g_Texture1;
            uniform sampler2D g_Texture2;
            uniform vec3 g_Screen;
            
            uniform float u_threshold;
            uniform float u_protrude;
            uniform float u_x_diff;
            uniform float u_y_diff;
            
            uniform float u_scaleX;
            uniform float u_scaleY;
            uniform float u_offsetX;
            uniform float u_offsetY;
            
            uniform float u_blurSize;
            uniform float u_blurDepth;
            uniform float u_depthImageBlurSize;
            
            uniform vec3 u_borderColor;
            uniform float u_borderSizeX, u_borderSizeY;
            
            varying vec2 v_TexCoord;
            
            vec2 mirrored(vec2 v) {
                vec2 m = mod(v, 2.);
                return mix(m, 2.0 - m, step(1.0, m));
            }
            
            vec4 convolute(vec2 uv, mat3 kernel, float size) {
                if(size < 1.0) return texture2D(g_Texture1, uv);
                vec4 color = vec4(0., 0., 0., 0.);
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        vec2 offset = vec2(float(x - 1), float(y - 1)) / g_Screen.xy * size;
                        color += texture2D(g_Texture1, uv + offset) * kernel[x][y];
                    }
                }
                return color;
            }
            
            vec4 convoluteDepth(vec2 uv, mat3 kernel, float size) {
                if(size < 1.0) return texture2D(g_Texture2, uv);
                vec4 color = vec4(0., 0., 0., 0.);
                for (int x = 0; x < 3; x++) {
                    for (int y = 0; y < 3; y++) {
                        vec2 offset = vec2(float(x - 1), float(y - 1)) / g_Screen.xy * size;
                        color += texture2D(g_Texture2, uv + offset) * kernel[x][y];
                    }
                }
                return color;
            }
            
            vec4 depthQuilts(vec2 iuv) {
                vec2 fractCoord = fract(iuv);
                float valueId = u_x_diff;
                float valueIdY = u_y_diff;
                
                vec2 uv = vec2(u_scaleX, u_scaleY) * (fractCoord - 0.5) + 0.5 + vec2(u_offsetX, u_offsetY);
                
                vec4 depthMap = convoluteDepth(uv, box_blur, u_depthImageBlurSize);//[0,1]
                float xOffset = (depthMap.r - 0.5 + u_protrude) * ((valueId) * 2.0 / u_threshold);
                float yOffset = (depthMap.r - 0.5 + u_protrude) * ((valueIdY) * 2.0 / u_threshold);
                vec2 fake3d = vec2(uv.x + xOffset, uv.y + yOffset);

                if((depthMap.r - 0.5 + u_protrude < 0.) && 
                    (fractCoord.x < u_borderSizeX || fractCoord.y < u_borderSizeY || 
                    fractCoord.x > (1. - u_borderSizeX) || fractCoord.y > (1. - u_borderSizeY))) {
                    return vec4(u_borderColor, 1.0);
                }

                vec4 color = depthMap.r < u_blurDepth ? 
                    convolute(mirrored(fake3d), gaussian_blur, u_blurSize) : 
                    texture2D(g_Texture1, fake3d);
                
                return color;
            }
            
            void main() {
                vec2 uv = v_TexCoord.xy;
                gl_FragColor = depthQuilts(uv);
            }
        `;
        
        // 初始化WebGL
        function initWebGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl', { preserveDrawingBuffer: true }) || canvas.getContext('experimental-webgl', { preserveDrawingBuffer: true });
            
            if (!gl) {
                alert('您的浏览器不支持WebGL');
                return false;
            }
            
            return true;
        }
        
        // 创建着色器
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('着色器编译错误:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // 创建着色器程序
        function createProgram() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('着色器程序链接错误:', gl.getProgramInfoLog(program));
                return false;
            }
            
            gl.useProgram(program);
            return true;
        }
        
        // 获取uniform位置
        function getUniforms() {
            const uniformNames = [
                'g_Texture0', 'g_Texture1', 'g_Texture2', 'g_Screen',
                'u_threshold', 'u_protrude', 'u_x_diff', 'u_y_diff',
                'u_scaleX', 'u_scaleY', 'u_offsetX', 'u_offsetY',
                'u_blurSize', 'u_blurDepth', 'u_depthImageBlurSize',
                'u_borderColor', 'u_borderSizeX', 'u_borderSizeY'
            ];
            
            uniformNames.forEach(name => {
                uniforms[name] = gl.getUniformLocation(program, name);
            });
        }
        
        // 创建纹理
        function createTexture(image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            
            return texture;
        }
        
        // 设置几何体
        function setupGeometry() {
            const vertices = new Float32Array([
                -1.0, -1.0, 0.0, 0.0, 1.0,
                 1.0, -1.0, 0.0, 1.0, 1.0,
                -1.0,  1.0, 0.0, 0.0, 0.0,
                 1.0,  1.0, 0.0, 1.0, 0.0
            ]);
            
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_Position');
            const texCoordLocation = gl.getAttribLocation(program, 'a_TexCoord');
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 20, 0);
            
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 20, 12);
        }

        // 16进制颜色转RGB
        function hexToRgb(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255.0,
                g: parseInt(result[2], 16) / 255.0,
                b: parseInt(result[3], 16) / 255.0
            } : { r: 0, g: 0, b: 0 };
        }
        
        // 渲染场景
        function render() {
            const canvas = gl.canvas;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // 设置纹理
            if (textures.image) {
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, textures.image);
                gl.uniform1i(uniforms.g_Texture1, 1);
            }
            
            if (textures.depth) {
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, textures.depth);
                gl.uniform1i(uniforms.g_Texture2, 2);
            }
            
            // 设置uniform值
            gl.uniform3f(uniforms.g_Screen, canvas.width, canvas.height, 1.0);
            
            // 从控件获取参数值
            gl.uniform1f(uniforms.u_threshold, parseFloat(document.getElementById('threshold').value));
            gl.uniform1f(uniforms.u_protrude, parseFloat(document.getElementById('protrude').value));
            gl.uniform1f(uniforms.u_x_diff, parseFloat(document.getElementById('x_diff').value));
            gl.uniform1f(uniforms.u_y_diff, parseFloat(document.getElementById('y_diff').value));
            
            gl.uniform1f(uniforms.u_scaleX, parseFloat(document.getElementById('scaleX').value));
            gl.uniform1f(uniforms.u_scaleY, parseFloat(document.getElementById('scaleY').value));
            gl.uniform1f(uniforms.u_offsetX, parseFloat(document.getElementById('offsetX').value));
            gl.uniform1f(uniforms.u_offsetY, parseFloat(document.getElementById('offsetY').value));
            
            gl.uniform1f(uniforms.u_blurSize, parseFloat(document.getElementById('blurSize').value));
            gl.uniform1f(uniforms.u_blurDepth, parseFloat(document.getElementById('blurDepth').value));
            gl.uniform1f(uniforms.u_depthImageBlurSize, parseFloat(document.getElementById('depthImageBlurSize').value));
            
            const borderColorHex = document.getElementById('borderColor').value;
            const borderColorRgb = hexToRgb(borderColorHex);
            gl.uniform3f(uniforms.u_borderColor, borderColorRgb.r, borderColorRgb.g, borderColorRgb.b);
            gl.uniform1f(uniforms.u_borderSizeX, parseFloat(document.getElementById('borderSizeX').value));
            gl.uniform1f(uniforms.u_borderSizeY, parseFloat(document.getElementById('borderSizeY').value));
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        
        // 加载图像文件
        function loadImage(file, textureKey, previewId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    textures[textureKey] = createTexture(img);

                    // 记录纹理尺寸
                    const w = img.naturalWidth || img.width || 0;
                    const h = img.naturalHeight || img.height || 0;
                    if (textureKey === 'image') {
                        textures.imageWidth = w;
                        textures.imageHeight = h;
                    } else if (textureKey === 'depth') {
                        textures.depthWidth = w;
                        textures.depthHeight = h;
                    }

                    // 自适应调整画布分辨率：优先使用原图尺寸；如未提供原图则使用深度图尺寸
                    (function adjustCanvasSize() {
                        const canvas = document.getElementById('glCanvas');
                        if (!canvas) return;
                        let targetW = 0, targetH = 0;
                        if (textures.imageWidth && textures.imageHeight) {
                            targetW = textures.imageWidth;
                            targetH = textures.imageHeight;
                        } else if (textures.depthWidth && textures.depthHeight) {
                            targetW = textures.depthWidth;
                            targetH = textures.depthHeight;
                        }
                        if (targetW > 0 && targetH > 0) {
                            // 仅当变化时再设置，避免无谓重绘
                            if (canvas.width !== targetW || canvas.height !== targetH) {
                                canvas.width = Math.floor(targetW);
                                canvas.height = Math.floor(targetH);
                            }
                        }
                    })();

                    const preview = document.getElementById(previewId);
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // 设置控件事件监听器
        function setupControls() {
            const controls = [
                'threshold', 'protrude', 'x_diff', 'y_diff',
                'scaleX', 'scaleY', 'offsetX', 'offsetY',
                'blurSize', 'blurDepth', 'depthImageBlurSize',
                'borderSizeX', 'borderSizeY'
            ];
            
            controls.forEach(id => {
                const control = document.getElementById(id);
                const valueDisplay = document.getElementById(id + 'Value');
                
                control.addEventListener('input', function() {
                    let decimals = (this.step.toString().split('.')[1] || []).length;
                    valueDisplay.textContent = parseFloat(this.value).toFixed(decimals > 2 ? 5 : 3);
                    render();
                });
            });

            // 颜色选择器监听器
            document.getElementById('borderColor').addEventListener('input', render);
            
            // 文件输入监听器
            document.getElementById('imageFile').addEventListener('change', function(e) {
                if (e.target.files[0]) {
                    loadImage(e.target.files[0], 'image', 'imagePreview');
                }
            });
            
            document.getElementById('depthFile').addEventListener('change', function(e) {
                if (e.target.files[0]) {
                    loadImage(e.target.files[0], 'depth', 'depthPreview');
                }
            });
        }
        
        // 初始化应用
        function init() {
            if (!initWebGL()) return;
            
            if (!createProgram()) return;
            
            getUniforms();
            setupGeometry();
            setupControls();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            // 创建默认纹理
            const defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, defaultTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
            
            textures.image = defaultTexture;
            textures.depth = defaultTexture;
            textures.imageWidth = 1;
            textures.imageHeight = 1;
            
            render();
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);

        // 交互：在画布上拖拽以调整 x_diff / y_diff
    (function enableDragToAdjustDiff() {
            const canvas = document.getElementById('glCanvas');
            const xSlider = document.getElementById('x_diff');
            const ySlider = document.getElementById('y_diff');
            const xLabel = document.getElementById('x_diffValue');
            const yLabel = document.getElementById('y_diffValue');

            if (!canvas || !xSlider || !ySlider || !xLabel || !yLabel) return;

            let dragging = false;
            let startX = 0;
            let startY = 0;
            let startXVal = parseFloat(xSlider.value);
            let startYVal = parseFloat(ySlider.value);

            // 将像素拖拽映射到 [-0.5, 0.5] 范围的增量，按画布尺寸自适应
            function pxToDelta(dx, dy) {
                const rangeMin = parseFloat(xSlider.min); 
                const rangeMax = parseFloat(xSlider.max);
                const range = rangeMax - rangeMin;
                // 横向：拖满画布宽度相当于整个范围
                const deltaX = (-dx / canvas.clientWidth) * range;
                // 纵向：向上拖为正（与 UI 一致可根据需要调整）
                const deltaY = (-dy / canvas.clientHeight) * range;
                return { deltaX, deltaY };
            }

            function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

            function updateUI(xVal, yVal) {
                xSlider.value = xVal.toFixed(3);
                ySlider.value = yVal.toFixed(3);
                xLabel.textContent = parseFloat(xSlider.value).toFixed(3);
                yLabel.textContent = parseFloat(ySlider.value).toFixed(3);
                render();
            }

            canvas.addEventListener('mousedown', (e) => {
                dragging = true;
                canvas.style.cursor = 'grabbing';
                startX = e.clientX;
                startY = e.clientY;
                startXVal = parseFloat(xSlider.value);
                startYVal = parseFloat(ySlider.value);
                e.preventDefault();
            });

            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const { deltaX, deltaY } = pxToDelta(dx, dy);
                const newX = clamp(startXVal + deltaX, parseFloat(xSlider.min), parseFloat(xSlider.max));
                const newY = clamp(startYVal + deltaY, parseFloat(ySlider.min), parseFloat(ySlider.max));
                updateUI(newX, newY);
            });

            function endDrag() {
                if (!dragging) return;
                dragging = false;
                canvas.style.cursor = 'grab';
            }

            window.addEventListener('mouseup', endDrag);
            window.addEventListener('mouseleave', endDrag);
        })();

        // 陀螺仪控制 x_diff / y_diff
        (function enableGyroControl() {
            const btn = document.getElementById('enableGyroBtn');
            const statusEl = document.getElementById('gyroStatus');
            const sensSlider = document.getElementById('gyroSensitivity');
            const sensLabel = document.getElementById('gyroSensitivityValue');
            const xSlider = document.getElementById('x_diff');
            const ySlider = document.getElementById('y_diff');
            const xLabel = document.getElementById('x_diffValue');
            const yLabel = document.getElementById('y_diffValue');

            if (!btn || !statusEl || !sensSlider || !sensLabel) return;

            let enabled = false;
            let rafId = null;
            // 平滑与限制
            let targetX = 0, targetY = 0;
            let currentX = parseFloat(xSlider.value), currentY = parseFloat(ySlider.value);
            const alpha = 0.15; // 低通滤波系数，越大越跟手
            // 以启用时姿态为零基准
            let baseBeta = null, baseGamma = null; // 记录启用后的首帧姿态
            let startXAtEnable = parseFloat(xSlider.value), startYAtEnable = parseFloat(ySlider.value); // 启用时滑块的基准值

            function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

            function setDiff(x, y) {
                xSlider.value = x.toFixed(3);
                ySlider.value = y.toFixed(3);
                xLabel.textContent = parseFloat(xSlider.value).toFixed(3);
                yLabel.textContent = parseFloat(ySlider.value).toFixed(3);
                render();
            }

            function updateSensitivityUI() {
                const decimals = (sensSlider.step.toString().split('.')[1] || []).length;
                sensLabel.textContent = parseFloat(sensSlider.value).toFixed(decimals > 2 ? 5 : 3);
            }
            sensSlider.addEventListener('input', updateSensitivityUI);
            updateSensitivityUI();

            // 将设备方向(或相对变化)映射到 [-0.5, 0.5]
            // 使用 gamma(水平左右) -> x_diff, beta(前后俯仰) -> y_diff
            // 依据屏幕方向进行简单适配
            function orientationToDiff(beta, gamma) {
                const sens = parseFloat(sensSlider.value); // 0~3
                // 设备原始范围：beta [-180,180]，gamma [-90,90]
                // 先归一化到 [-1,1]，再乘以 0.5 与灵敏度，并限制
                const normGamma = clamp(gamma / 90, -1, 1); // 左右
                const normBeta = clamp(beta / 90, -1, 1);   // 前后

                let x = -normGamma * 0.5 * sens;
                let y = -normBeta * 0.5 * sens; // 俯仰向前(正beta)让 y 偏转为负，体验更自然

                // 屏幕方向适配
                const orient = (screen && screen.orientation && screen.orientation.type) || '';
                if (orient.includes('landscape')) {
                    // 横屏下左右/上下轴可能对调，进行轻度交换与符号调整
                    const t = x; x = -y; y = t;
                }

                return { x, y };
            }

            function onDeviceOrientation(e) {
                // 某些浏览器只提供 webkitCompassHeading 等，这里主要用 beta/gamma
                const beta = (typeof e.beta === 'number') ? e.beta : 0;
                const gamma = (typeof e.gamma === 'number') ? e.gamma : 0;
                // 首次读数作为零基准，避免启用瞬间跳变
                if (baseBeta === null || baseGamma === null) {
                    baseBeta = beta;
                    baseGamma = gamma;
                    // 保持当前目标为启用时滑块值
                    targetX = startXAtEnable;
                    targetY = startYAtEnable;
                    return;
                }

                // 使用相对变化值驱动，围绕启用时滑块值偏移
                const dBeta = beta - baseBeta;
                const dGamma = gamma - baseGamma;
                const { x, y } = orientationToDiff(dBeta, dGamma); // 这里返回的是相对偏移量
                const minX = parseFloat(xSlider.min), maxX = parseFloat(xSlider.max);
                const minY = parseFloat(ySlider.min), maxY = parseFloat(ySlider.max);
                targetX = clamp(startXAtEnable + x, minX, maxX);
                targetY = clamp(startYAtEnable + y, minY, maxY);
            }

            function animate() {
                if (!enabled) return;
                // 简单低通滤波，缓动到 target
                currentX += (targetX - currentX) * alpha;
                currentY += (targetY - currentY) * alpha;
                setDiff(currentX, currentY);
                rafId = requestAnimationFrame(animate);
            }

            async function requestPermissionIfNeeded() {
                try {
                    const AnyOrientation = window.DeviceOrientationEvent || window.DeviceMotionEvent;
                    if (!AnyOrientation) {
                        throw new Error('不支持设备方向');
                    }
                    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS 13+ 需要手势触发
                        const res = await DeviceOrientationEvent.requestPermission();
                        if (res !== 'granted') throw new Error('权限被拒绝');
                    }
                    return true;
                } catch (err) {
                    console.warn(err);
                    return false;
                }
            }

            function enable() {
                if (enabled) return;
                enabled = true;
                statusEl.textContent = '已启用';
                statusEl.style.color = '#4CAF50';
                window.addEventListener('deviceorientation', onDeviceOrientation, true);
                // 初始化当前与目标
                currentX = parseFloat(xSlider.value);
                currentY = parseFloat(ySlider.value);
                startXAtEnable = currentX;
                startYAtEnable = currentY;
                // 清空基准，等待首帧姿态设零
                baseBeta = null;
                baseGamma = null;
                targetX = currentX;
                targetY = currentY;
                animate();
            }

            function disable() {
                if (!enabled) return;
                enabled = false;
                statusEl.textContent = '未启用';
                statusEl.style.color = '#aaa';
                window.removeEventListener('deviceorientation', onDeviceOrientation, true);
                if (rafId) cancelAnimationFrame(rafId);
                rafId = null;
                baseBeta = null;
                baseGamma = null;
            }

            btn.addEventListener('click', async () => {
                if (!enabled) {
                    const ok = await requestPermissionIfNeeded();
                    if (!ok) {
                        statusEl.textContent = '权限被拒或不支持';
                        statusEl.style.color = '#f39c12';
                        return;
                    }
                    enable();
                    btn.textContent = '关闭陀螺仪控制';
                } else {
                    disable();
                    btn.textContent = '启用陀螺仪控制';
                }
            });
        })();
    </script>
</body>
</html>
